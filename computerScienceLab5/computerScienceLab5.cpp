#include <iostream>  // Подключение библиотеки для работы с вводом/выводом
#include <cmath>      // Подключение библиотеки для математических операций
#include <limits>     // Подключение библиотеки для работы с пределами типов данных
#include <string>     // Подключение библиотеки для работы со строками
#include <sstream>    // Подключение библиотеки для обработки строковых потоков
#include <crtdbg.h>   // Подключение библиотеки для проверки утечек памяти в Visual Studio

using namespace std; // Использование пространства имен std для упрощения записи

// Функция для проверки корректного ввода числа
// Принимает ссылку на переменную value, чтобы изменить ее значение напрямую
// Используется stringstream для строгой проверки ввода
template <typename T>
T inputCheck() {
    string input; // Переменная для хранения пользовательского ввода
    T value; // Переменная для хранения результата ввода
    while (true) {
        getline(cin, input); // Считывание всей строки ввода
        stringstream ss(input); // Создание потока для обработки строки
        T temp; // Переменная для временного хранения числа
        char extra; // Переменная для проверки лишних символов

        // ss >> temp - Попытка извлечь значение из потока stringstream в переменную temp, возвращает bool
        // true - если значение успешно извлечено
        // false - если произошла ошибка при извлечении значения

        // ss >> extra - попытка извлечь оставшиеся данные, после извлечения в temp.
        // Если что-то осталось, то вернёт true. Нам нужно чтобы ничего не оставалось, поэтому инвертируем с помощью !
        if (ss >> temp && !(ss >> extra)) { // Проверка: ввод должен содержать только одно корректное число
            value = temp; // Присваивание корректного значения переменной
            return value; // Возвращаем введенное значение
        }
        else {
            cout << "Ошибка! Введите корректные данные: " << endl; // Сообщение об ошибке
        }
    }
}

// Функция для поиска индекса максимального по модулю элемента
// Принимает указатель на массив (const double* arr) - неизменяемая ссылка на массив
// Это позволяет передавать массив по ссылке без копирования
int findMaxAbsIndex(const double* arr, int n) {
    int maxIndex = 0; // Переменная для хранения индекса максимального элемента
    for (int i = 0; i < n; i++) { // Перебор всех элементов массива
        if (fabs(arr[i]) > fabs(arr[maxIndex])) { // Проверка на максимальное значение по модулю
            maxIndex = i; // Обновление индекса максимального элемента
        }
    }
    return maxIndex; // Возвращение найденного индекса
}

// Функция для вычисления суммы модулей элементов после первого положительного
// Использует указатель на неизменяемый массив (const double* arr)
// Возвращает -1, если первое положительное число является последним элементом в массиве, либо если положительных чисел в массиве нет.
double sumAfterFirstPositive(const double* arr, int n) {
    bool foundPositive = false; // Флаг для определения первого положительного элемента
    double sum = -1; // Переменная для хранения суммы модулей
    for (int i = 0; i < n; i++) { // Перебор всех элементов массива
        if (foundPositive) { // Если найден положительный элемент
            sum += fabs(arr[i]); // Добавление модуля элемента к сумме
            continue;
        }
        if (arr[i] > 0) { // Поиск первого положительного элемента
            foundPositive = true; // Установка флага
        }
    }
    return sum; // Возвращение вычисленной суммы
}

// Функция для перестановки элементов по критерию
// Использует указатель на массив (double* arr), передаваемый по ссылке
void rearrangeArray(double* arr, int n, double a, double b) {
    int left = 0, right = 0; // Счетчики для хранения количества элементов
    double* temp = new double[n]; // Динамическое выделение памяти для временного массива

    // Заполняем временный массив элементами, целая часть которых в [a; b]
    for (int i = 0; i < n; i++) {
        if (floor(arr[i]) >= a && floor(arr[i]) <= b) { // Проверка попадания в диапазон [a, b]
            temp[left++] = arr[i]; // Добавление в левую часть временного массива
        }
    }

    // Добавляем остальные элементы
    for (int i = 0; i < n; i++) {
        if (!(floor(arr[i]) >= a && floor(arr[i]) <= b)) { // Если элемент не попадает в диапазон
            temp[left + right++] = arr[i]; // Добавление в правую часть временного массива
        }
    }

    // Копируем обратно в оригинальный массив
    for (int i = 0; i < n; i++) {
        arr[i] = temp[i]; // Перезапись оригинального массива
    }

    delete[] temp; // Освобождение памяти
}



int main() {
    // Включение проверки утечек памяти в Visual Studio
#ifdef _MSC_VER
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
#endif

    int n; // Переменная для хранения размера массива
    cout << "Введите размер массива: " << endl;
    n = inputCheck<int>(); // Проверка корректности ввода размера массива

    double* arr = new double[n]; // Динамическое выделение памяти для массива

    cout << "Введите элементы массива: ";
    for (int i = 0; i < n; i++) {
        arr[i] = inputCheck<double>(); // Ввод элементов массива с проверкой
    }

    int maxAbsIndex = findMaxAbsIndex(arr, n); // Получение индекса максимального по модулю элемента
    cout << "Индекс максимального по модулю элемента: " << maxAbsIndex << endl;

    double sumMod = sumAfterFirstPositive(arr, n); // Вычисление суммы модулей после первого положительного
    if (sumMod == -1) 
    {
        cout << "Первое положительное число является последним элементом в массиве, либо если положительных чисел в массиве нет." << endl;
    } 
    else 
    {
        cout << "Сумма модулей элементов после первого положительного: " << sumMod << endl;
    }
    

    double a, b; // Переменные для границ диапазона
    cout << "Введите a и b для перестановки: ";
    a = inputCheck<double>();
    b = inputCheck<double>();

    rearrangeArray(arr, n, a, b); // Перестановка элементов массива по критерию

    cout << "Преобразованный массив: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " "; // Вывод элементов преобразованного массива
    }
    cout << endl;

    delete[] arr; // Освобождение памяти, предотвращение утечек

    return 0; // Завершение программы
}
